
#include "include/kernel.h"
#include "include/memory.h"
#include "include/fs.h"
#include "include/errno.h"

static inode_t *root_inode = NULL;

static int strcmp(const char *s1, const char *s2) {
    while (*s1 && (*s1 == *s2)) {
        s1++;
        s2++;
    }
    return *(unsigned char *)s1 - *(unsigned char *)s2;
}

inode_t *vfs_lookup(const char *path) {
    if (!path || path[0] != '/') {
        return NULL;
    }

    if (strcmp(path, "/") == 0) {
        return root_inode;
    }

    inode_t *current = root_inode;
    const char *p = path + 1;

    while (*p && current) {

        const char *start = p;
        while (*p && *p != '/') p++;

        size_t len = p - start;
        if (len == 0) {
            if (*p == '/') p++;
            continue;
        }

        if (current->type != FT_DIR || !current->i_ops || !current->i_ops->lookup) {
            return NULL;
        }

        char name[NAME_MAX];
        if (len >= NAME_MAX) len = NAME_MAX - 1;
        for (size_t i = 0; i < len; i++) {
            name[i] = start[i];
        }
        name[len] = '\0';

        current = current->i_ops->lookup(current, name);

        if (*p == '/') p++;
    }

    return current;
}

file_t *vfs_open(const char *path, int flags) {
    inode_t *inode = vfs_lookup(path);
    if (!inode) {
        return NULL;
    }

    file_t *file = physmem_alloc_page();
    if (!file) {
        return NULL;
    }

    memset(file, 0, sizeof(file_t));
    file->inode = inode;
    file->offset = 0;
    file->flags = flags;
    file->refcount = 1;
    file->ops = inode->f_ops;

    if (file->ops && file->ops->open) {
        int ret = file->ops->open(file);
        if (ret < 0) {
            physmem_free_page(file);
            return NULL;
        }
    }

    return file;
}

int vfs_close(file_t *f) {
    if (!f) return -EBADF;

    f->refcount--;
    if (f->refcount <= 0) {
        if (f->ops && f->ops->close) {
            f->ops->close(f);
        }
        physmem_free_page(f);
    }

    return 0;
}

int64_t vfs_read(file_t *f, void *buf, size_t count) {
    if (!f || !buf) return -EFAULT;
    if (!f->ops || !f->ops->read) return -ENOSYS;

    return f->ops->read(f, buf, count);
}

int64_t vfs_write(file_t *f, const void *buf, size_t count) {
    if (!f || !buf) return -EFAULT;
    if (!f->ops || !f->ops->write) return -ENOSYS;

    return f->ops->write(f, buf, count);
}

int64_t vfs_lseek(file_t *f, int64_t offset, int whence) {
    if (!f) return -EBADF;

    if (f->ops && f->ops->lseek) {
        return f->ops->lseek(f, offset, whence);
    }

    int64_t new_offset;
    switch (whence) {
        case SEEK_SET:
            new_offset = offset;
            break;
        case SEEK_CUR:
            new_offset = f->offset + offset;
            break;
        case SEEK_END:
            new_offset = f->inode->size + offset;
            break;
        default:
            return -EINVAL;
    }

    if (new_offset < 0) return -EINVAL;
    f->offset = new_offset;
    return new_offset;
}

void vfs_set_root(inode_t *root) {
    root_inode = root;
}

void vfs_init(void) {
    root_inode = NULL;
}
